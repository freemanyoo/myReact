함수형 컴포넌트에서,  hooks , 개념 및 기본기.
- hook : 고리, 특정 시점에서 끼어 들어서 동작을 수행함.
일반적인 실행 흐름 : a -> b-> c -> d -> e
Hook 사용시 : a -> b -> hook 실행 -> c -> d -> e
=====================================================================
1
useState
: React의 함수형 컴포넌트에서 상태(state)를 관리하기 위해 사용하는 Hook
상태 ?
컴포넌트의 데이터로, 값이 변경되면 화면(UI)을 자동으로 다시 렌더링합니다.
주요 특징
상태 값 저장: 컴포넌트 내에서 값을 유지
값 변경 시 자동 렌더링: UI가 상태 변화에 맞게 자동 업데이트
함수형 컴포넌트 전용: 클래스형 컴포넌트의 this.state와 같은 역할
기본 문법
const [state, setState] = useState(initialValue);

state: 현재 상태 값
setState: 상태를 변경하는 함수
initialValue: 상태의 초기값
=====================================================================
2
useEffect
: 사이드 이펙트(Side Effect) 처리하기 위한 hook
사이드 이펙트(Side Effect) ?
컴포넌트의 렌더링 과정 외부에서 발생하는 작업
1) API 호출 ,
2) DOM 직접 조작, (포커서, 스크롤, 등)
3) 타이머 설정 / 해제
4) 이벤트 리스너 등록 / 해제
5) 콘솔 로그, 로컬 스토리지에 저장.

기본 문법
useEffect(콜백함수, [의존성배열]);
useEffect(() => {
  // 실행할 코드
  return () => {
    // 정리(clean-up) 코드 (선택)
  };
}, [의존성배열]);

첫 번째 인자: 실행할 함수
두 번째 인자([]): 의존성 배열 (언제 실행할지 결정)

[] 빈 배열 → 최초 1회 실행 (마운트 시)

[값] 특정 값 변경 시 실행

없으면 → 렌더링마다 실행
=====================================================================
3
useReducer
:  상태 관리 로직이 복잡할 때 사용하는 Hook
다양한 상태 변경 패턴을 한 곳에서 관리할 수 있도록 도와줌.
왜 사용하나요?
1)
상태 변경 로직이 if/else나 setState 중첩으로 복잡해질 때
2)
여러 개의 상태 값이 서로 연관되어 변경될 때
3) 상태 관리 라이브러리 사용할 때,
Redux와 유사한 방식으로 액션 기반 상태 관리를 하고 싶을 때

기본 문법
const [state, dispatch] = useReducer(reducer, initialState);

state: 현재 상태 값
dispatch: 상태 변경 요청 함수
reducer: (state, action) => newState 형태의 함수
initialState: 초기 상태 값
=====================================================================
4
useMemo
메모이제이션(Memoization)된 값을 반환하는 Hook
메모이제이션(Memoization) ?
이미 계산한 값을 기억해두었다가,
동일한 계산을 반복해야 할 때
다시 계산하는 대신 기억해 둔 값을 바로 반환하여
성능을 최적화하는 기술입니다.
useMemo는 복잡한 연산의 결과값을 기억합니다.

사용처
1
성능 최적화: 렌더링마다 반복되는 복잡한 연산이나
계산 비용이 큰 함수의 실행을 방지하여 성능 저하를 막습니다.
2
불필요한 계산 방지: 의존성 배열의 값이 변경될 때만
콜백 함수를 다시 실행하여 값을 계산합니다.

기본문법
예시
useMemo(콜백함수, [의존성 배열])
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
:
useMemo가 반환하는 메모이제이션된 값.
의존성([a,b])이 바뀌지 않으면
이전 렌더링에서 계산된 값을 그대로 사용합니다.
=====================================================================
5
useCallback
: 메모이제이션(Memoization)된 함수를 반환하는 Hook

useMemo가 값(value)을 기억하는 반면,
useCallback은 함수(function) 자체를 기억합니다.
렌더링이 발생해도 의존성 배열의 값이 변경되지 않으면
이전에 생성된 함수를 그대로 재사용합니다.

사용처
1
자식 컴포넌트의 불필요한 리렌더링 방지:
함수형 컴포넌트는 렌더링될 때마다 내부에 선언된 함수도 새로 생성됩니다.
이 새로운 함수를 자식 컴포넌트에 props로 전달하면,
자식 컴포넌트는 부모로부터 받은 props가 변경되었다고 인식하여
불필요하게 리렌더링될 수 있습니다.
useCallback은 함수를 재사용하게 하여 이를 방지합니다.
(React.memo와 함께 사용할 때 효과가 극대화됩니다.)
2
의존성 관리:
useEffect와 같은 다른 Hook의 의존성 배열에 함수를 포함해야 할 때,
렌더링마다 함수가 재생성되어
useEffect가 불필요하게 계속 실행되는 것을 막을 수 있습니다.

기본문법
useCallback(콜백 함수, [의존성 배열])
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);










